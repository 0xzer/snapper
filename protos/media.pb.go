// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.30.0
// 	protoc        v3.21.12
// source: media.proto

package protos

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// The "DO_NOT_CLAIM" means that the media, once initially referenced, should
// have a fixed ttl, and thus it should not be re-claimed on a go-forward basis.
// For CAN_EXTEND_MEDIA_CLAIM cases, the party delivering the Snap in context
// should be responsible for making sure there's a claim matching the life cycle
// of this snap/snapdoc.
type MediaReference_ClaimBehavior int32

const (
	MediaReference_ClaimBehavior_REFERENCE_CAN_EXTEND_MEDIA_CLAIM MediaReference_ClaimBehavior = 0
	MediaReference_ClaimBehavior_REFERENCE_DO_NOT_CLAIM           MediaReference_ClaimBehavior = 1
)

// Enum value maps for MediaReference_ClaimBehavior.
var (
	MediaReference_ClaimBehavior_name = map[int32]string{
		0: "REFERENCE_CAN_EXTEND_MEDIA_CLAIM",
		1: "REFERENCE_DO_NOT_CLAIM",
	}
	MediaReference_ClaimBehavior_value = map[string]int32{
		"REFERENCE_CAN_EXTEND_MEDIA_CLAIM": 0,
		"REFERENCE_DO_NOT_CLAIM":           1,
	}
)

func (x MediaReference_ClaimBehavior) Enum() *MediaReference_ClaimBehavior {
	p := new(MediaReference_ClaimBehavior)
	*p = x
	return p
}

func (x MediaReference_ClaimBehavior) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MediaReference_ClaimBehavior) Descriptor() protoreflect.EnumDescriptor {
	return file_media_proto_enumTypes[0].Descriptor()
}

func (MediaReference_ClaimBehavior) Type() protoreflect.EnumType {
	return &file_media_proto_enumTypes[0]
}

func (x MediaReference_ClaimBehavior) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MediaReference_ClaimBehavior.Descriptor instead.
func (MediaReference_ClaimBehavior) EnumDescriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{0}
}

type VideoDescription_VideoPlaybackType int32

const (
	VideoDescription_VideoPlaybackType_VIDEO_UNKNOWN_PLAYBACK_TYPE VideoDescription_VideoPlaybackType = 0
	// * FASTSTART_DISABLED - Canâ€™t progressively stream; since MOOV atom is at the end
	VideoDescription_VideoPlaybackType_VIDEO_FASTSTART_DISABLED VideoDescription_VideoPlaybackType = 1
	// * FASTSTART_ENABLED - Capable of progressive streaming; with MOOV atom at the front
	VideoDescription_VideoPlaybackType_VIDEO_FASTSTART_ENABLED   VideoDescription_VideoPlaybackType = 2
	VideoDescription_VideoPlaybackType_VIDEO_HTTP_STREAMING_DASH VideoDescription_VideoPlaybackType = 3
	VideoDescription_VideoPlaybackType_VIDEO_HTTP_STREAMING_HLS  VideoDescription_VideoPlaybackType = 4
)

// Enum value maps for VideoDescription_VideoPlaybackType.
var (
	VideoDescription_VideoPlaybackType_name = map[int32]string{
		0: "VIDEO_UNKNOWN_PLAYBACK_TYPE",
		1: "VIDEO_FASTSTART_DISABLED",
		2: "VIDEO_FASTSTART_ENABLED",
		3: "VIDEO_HTTP_STREAMING_DASH",
		4: "VIDEO_HTTP_STREAMING_HLS",
	}
	VideoDescription_VideoPlaybackType_value = map[string]int32{
		"VIDEO_UNKNOWN_PLAYBACK_TYPE": 0,
		"VIDEO_FASTSTART_DISABLED":    1,
		"VIDEO_FASTSTART_ENABLED":     2,
		"VIDEO_HTTP_STREAMING_DASH":   3,
		"VIDEO_HTTP_STREAMING_HLS":    4,
	}
)

func (x VideoDescription_VideoPlaybackType) Enum() *VideoDescription_VideoPlaybackType {
	p := new(VideoDescription_VideoPlaybackType)
	*p = x
	return p
}

func (x VideoDescription_VideoPlaybackType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VideoDescription_VideoPlaybackType) Descriptor() protoreflect.EnumDescriptor {
	return file_media_proto_enumTypes[1].Descriptor()
}

func (VideoDescription_VideoPlaybackType) Type() protoreflect.EnumType {
	return &file_media_proto_enumTypes[1]
}

func (x VideoDescription_VideoPlaybackType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VideoDescription_VideoPlaybackType.Descriptor instead.
func (VideoDescription_VideoPlaybackType) EnumDescriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{1}
}

// *
// The higher the value, the higher the media quality.
type VideoDescription_MediaQualityType int32

const (
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_UNKNOWN   VideoDescription_MediaQualityType = 0
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_1   VideoDescription_MediaQualityType = 100
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2   VideoDescription_MediaQualityType = 200
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_3   VideoDescription_MediaQualityType = 300
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_4   VideoDescription_MediaQualityType = 400
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_5   VideoDescription_MediaQualityType = 500
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_6   VideoDescription_MediaQualityType = 600
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_7   VideoDescription_MediaQualityType = 700
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_MAX VideoDescription_MediaQualityType = 5000
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_4_5 VideoDescription_MediaQualityType = 450
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2_1 VideoDescription_MediaQualityType = 210
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2_2 VideoDescription_MediaQualityType = 220
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2_5 VideoDescription_MediaQualityType = 250
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_3_2 VideoDescription_MediaQualityType = 320
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_3_5 VideoDescription_MediaQualityType = 350
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2_7 VideoDescription_MediaQualityType = 270
	VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_LEVEL_6_5 VideoDescription_MediaQualityType = 650
)

// Enum value maps for VideoDescription_MediaQualityType.
var (
	VideoDescription_MediaQualityType_name = map[int32]string{
		0:    "VIDEO_MEDIA_QUALITY_TYPE_UNKNOWN",
		100:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_1",
		200:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2",
		300:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_3",
		400:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_4",
		500:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_5",
		600:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_6",
		700:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_7",
		5000: "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_MAX",
		450:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_4_5",
		210:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2_1",
		220:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2_2",
		250:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2_5",
		320:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_3_2",
		350:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_3_5",
		270:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2_7",
		650:  "VIDEO_MEDIA_QUALITY_TYPE_LEVEL_6_5",
	}
	VideoDescription_MediaQualityType_value = map[string]int32{
		"VIDEO_MEDIA_QUALITY_TYPE_UNKNOWN":   0,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_1":   100,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2":   200,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_3":   300,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_4":   400,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_5":   500,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_6":   600,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_7":   700,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_MAX": 5000,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_4_5": 450,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2_1": 210,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2_2": 220,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2_5": 250,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_3_2": 320,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_3_5": 350,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_2_7": 270,
		"VIDEO_MEDIA_QUALITY_TYPE_LEVEL_6_5": 650,
	}
)

func (x VideoDescription_MediaQualityType) Enum() *VideoDescription_MediaQualityType {
	p := new(VideoDescription_MediaQualityType)
	*p = x
	return p
}

func (x VideoDescription_MediaQualityType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VideoDescription_MediaQualityType) Descriptor() protoreflect.EnumDescriptor {
	return file_media_proto_enumTypes[2].Descriptor()
}

func (VideoDescription_MediaQualityType) Type() protoreflect.EnumType {
	return &file_media_proto_enumTypes[2]
}

func (x VideoDescription_MediaQualityType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VideoDescription_MediaQualityType.Descriptor instead.
func (VideoDescription_MediaQualityType) EnumDescriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{2}
}

type VideoFileFormat int32

const (
	VideoFileFormat_VIDEO_FILE_UNSET VideoFileFormat = 0
	VideoFileFormat_VIDEO_FILE_MP4   VideoFileFormat = 1
	VideoFileFormat_VIDEO_FILE_FMP4  VideoFileFormat = 2
)

// Enum value maps for VideoFileFormat.
var (
	VideoFileFormat_name = map[int32]string{
		0: "VIDEO_FILE_UNSET",
		1: "VIDEO_FILE_MP4",
		2: "VIDEO_FILE_FMP4",
	}
	VideoFileFormat_value = map[string]int32{
		"VIDEO_FILE_UNSET": 0,
		"VIDEO_FILE_MP4":   1,
		"VIDEO_FILE_FMP4":  2,
	}
)

func (x VideoFileFormat) Enum() *VideoFileFormat {
	p := new(VideoFileFormat)
	*p = x
	return p
}

func (x VideoFileFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VideoFileFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_media_proto_enumTypes[3].Descriptor()
}

func (VideoFileFormat) Type() protoreflect.EnumType {
	return &file_media_proto_enumTypes[3]
}

func (x VideoFileFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VideoFileFormat.Descriptor instead.
func (VideoFileFormat) EnumDescriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{3}
}

type AudioCodecFormat int32

const (
	AudioCodecFormat_AUDIO_CODEC_UNSET AudioCodecFormat = 0
	AudioCodecFormat_AUDIO_CODEC_AAC   AudioCodecFormat = 1
	AudioCodecFormat_AUDIO_CODEC_HEAAC AudioCodecFormat = 2
	AudioCodecFormat_AUDIO_CODEC_OPUS  AudioCodecFormat = 3
)

// Enum value maps for AudioCodecFormat.
var (
	AudioCodecFormat_name = map[int32]string{
		0: "AUDIO_CODEC_UNSET",
		1: "AUDIO_CODEC_AAC",
		2: "AUDIO_CODEC_HEAAC",
		3: "AUDIO_CODEC_OPUS",
	}
	AudioCodecFormat_value = map[string]int32{
		"AUDIO_CODEC_UNSET": 0,
		"AUDIO_CODEC_AAC":   1,
		"AUDIO_CODEC_HEAAC": 2,
		"AUDIO_CODEC_OPUS":  3,
	}
)

func (x AudioCodecFormat) Enum() *AudioCodecFormat {
	p := new(AudioCodecFormat)
	*p = x
	return p
}

func (x AudioCodecFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AudioCodecFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_media_proto_enumTypes[4].Descriptor()
}

func (AudioCodecFormat) Type() protoreflect.EnumType {
	return &file_media_proto_enumTypes[4]
}

func (x AudioCodecFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AudioCodecFormat.Descriptor instead.
func (AudioCodecFormat) EnumDescriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{4}
}

type ImageCodecFormat int32

const (
	ImageCodecFormat_IMAGE_CODEC_UNSET ImageCodecFormat = 0
	ImageCodecFormat_IMAGE_CODEC_JPEG  ImageCodecFormat = 1
	ImageCodecFormat_IMAGE_CODEC_PNG   ImageCodecFormat = 2
	ImageCodecFormat_IMAGE_CODEC_WEBP  ImageCodecFormat = 3
	ImageCodecFormat_IMAGE_CODEC_HEIF  ImageCodecFormat = 4
	ImageCodecFormat_IMAGE_CODEC_AWEBP ImageCodecFormat = 5
	ImageCodecFormat_IMAGE_CODEC_GIF   ImageCodecFormat = 6
)

// Enum value maps for ImageCodecFormat.
var (
	ImageCodecFormat_name = map[int32]string{
		0: "IMAGE_CODEC_UNSET",
		1: "IMAGE_CODEC_JPEG",
		2: "IMAGE_CODEC_PNG",
		3: "IMAGE_CODEC_WEBP",
		4: "IMAGE_CODEC_HEIF",
		5: "IMAGE_CODEC_AWEBP",
		6: "IMAGE_CODEC_GIF",
	}
	ImageCodecFormat_value = map[string]int32{
		"IMAGE_CODEC_UNSET": 0,
		"IMAGE_CODEC_JPEG":  1,
		"IMAGE_CODEC_PNG":   2,
		"IMAGE_CODEC_WEBP":  3,
		"IMAGE_CODEC_HEIF":  4,
		"IMAGE_CODEC_AWEBP": 5,
		"IMAGE_CODEC_GIF":   6,
	}
)

func (x ImageCodecFormat) Enum() *ImageCodecFormat {
	p := new(ImageCodecFormat)
	*p = x
	return p
}

func (x ImageCodecFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ImageCodecFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_media_proto_enumTypes[5].Descriptor()
}

func (ImageCodecFormat) Type() protoreflect.EnumType {
	return &file_media_proto_enumTypes[5]
}

func (x ImageCodecFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ImageCodecFormat.Descriptor instead.
func (ImageCodecFormat) EnumDescriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{5}
}

type VideoCodecFormat int32

const (
	VideoCodecFormat_VIDEO_CODEC_UNSET VideoCodecFormat = 0
	VideoCodecFormat_VIDEO_CODEC_H264  VideoCodecFormat = 1
	VideoCodecFormat_VIDEO_CODEC_HEVC  VideoCodecFormat = 2
	VideoCodecFormat_VIDEO_CODEC_AV1   VideoCodecFormat = 3
	VideoCodecFormat_VIDEO_CODEC_VP9   VideoCodecFormat = 4
)

// Enum value maps for VideoCodecFormat.
var (
	VideoCodecFormat_name = map[int32]string{
		0: "VIDEO_CODEC_UNSET",
		1: "VIDEO_CODEC_H264",
		2: "VIDEO_CODEC_HEVC",
		3: "VIDEO_CODEC_AV1",
		4: "VIDEO_CODEC_VP9",
	}
	VideoCodecFormat_value = map[string]int32{
		"VIDEO_CODEC_UNSET": 0,
		"VIDEO_CODEC_H264":  1,
		"VIDEO_CODEC_HEVC":  2,
		"VIDEO_CODEC_AV1":   3,
		"VIDEO_CODEC_VP9":   4,
	}
)

func (x VideoCodecFormat) Enum() *VideoCodecFormat {
	p := new(VideoCodecFormat)
	*p = x
	return p
}

func (x VideoCodecFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VideoCodecFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_media_proto_enumTypes[6].Descriptor()
}

func (VideoCodecFormat) Type() protoreflect.EnumType {
	return &file_media_proto_enumTypes[6]
}

func (x VideoCodecFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VideoCodecFormat.Descriptor instead.
func (VideoCodecFormat) EnumDescriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{6}
}

type MediaType int32

const (
	MediaType_MEDIA_TYPE_UNASSIGNED     MediaType = 0
	MediaType_MEDIA_TYPE_OVERLAY        MediaType = 1
	MediaType_MEDIA_TYPE_IMAGE          MediaType = 2
	MediaType_MEDIA_TYPE_VIDEO          MediaType = 3
	MediaType_MEDIA_TYPE_ASSETBUNDLE    MediaType = 4
	MediaType_MEDIA_TYPE_AUDIO          MediaType = 5
	MediaType_MEDIA_TYPE_ANIMATEDIMAGE  MediaType = 6
	MediaType_MEDIA_TYPE_FONT           MediaType = 7
	MediaType_MEDIA_TYPE_WEBVIEWCONTENT MediaType = 8
	MediaType_MEDIA_TYPE_VIDEONOAUDIO   MediaType = 9
	MediaType_MEDIA_TYPE_SUBTITLES      MediaType = 10
	MediaType_MEDIA_TYPE_DATABLOB       MediaType = 11
)

// Enum value maps for MediaType.
var (
	MediaType_name = map[int32]string{
		0:  "MEDIA_TYPE_UNASSIGNED",
		1:  "MEDIA_TYPE_OVERLAY",
		2:  "MEDIA_TYPE_IMAGE",
		3:  "MEDIA_TYPE_VIDEO",
		4:  "MEDIA_TYPE_ASSETBUNDLE",
		5:  "MEDIA_TYPE_AUDIO",
		6:  "MEDIA_TYPE_ANIMATEDIMAGE",
		7:  "MEDIA_TYPE_FONT",
		8:  "MEDIA_TYPE_WEBVIEWCONTENT",
		9:  "MEDIA_TYPE_VIDEONOAUDIO",
		10: "MEDIA_TYPE_SUBTITLES",
		11: "MEDIA_TYPE_DATABLOB",
	}
	MediaType_value = map[string]int32{
		"MEDIA_TYPE_UNASSIGNED":     0,
		"MEDIA_TYPE_OVERLAY":        1,
		"MEDIA_TYPE_IMAGE":          2,
		"MEDIA_TYPE_VIDEO":          3,
		"MEDIA_TYPE_ASSETBUNDLE":    4,
		"MEDIA_TYPE_AUDIO":          5,
		"MEDIA_TYPE_ANIMATEDIMAGE":  6,
		"MEDIA_TYPE_FONT":           7,
		"MEDIA_TYPE_WEBVIEWCONTENT": 8,
		"MEDIA_TYPE_VIDEONOAUDIO":   9,
		"MEDIA_TYPE_SUBTITLES":      10,
		"MEDIA_TYPE_DATABLOB":       11,
	}
)

func (x MediaType) Enum() *MediaType {
	p := new(MediaType)
	*p = x
	return p
}

func (x MediaType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MediaType) Descriptor() protoreflect.EnumDescriptor {
	return file_media_proto_enumTypes[7].Descriptor()
}

func (MediaType) Type() protoreflect.EnumType {
	return &file_media_proto_enumTypes[7]
}

func (x MediaType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MediaType.Descriptor instead.
func (MediaType) EnumDescriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{7}
}

type MediaUrlType int32

const (
	MediaUrlType_MEDIA_URL_TYPE_GCS                MediaUrlType = 0
	MediaUrlType_MEDIA_URL_TYPE_S3                 MediaUrlType = 1
	MediaUrlType_MEDIA_URL_TYPE_UNRECOGNIZED_VALUE MediaUrlType = 2
)

// Enum value maps for MediaUrlType.
var (
	MediaUrlType_name = map[int32]string{
		0: "MEDIA_URL_TYPE_GCS",
		1: "MEDIA_URL_TYPE_S3",
		2: "MEDIA_URL_TYPE_UNRECOGNIZED_VALUE",
	}
	MediaUrlType_value = map[string]int32{
		"MEDIA_URL_TYPE_GCS":                0,
		"MEDIA_URL_TYPE_S3":                 1,
		"MEDIA_URL_TYPE_UNRECOGNIZED_VALUE": 2,
	}
)

func (x MediaUrlType) Enum() *MediaUrlType {
	p := new(MediaUrlType)
	*p = x
	return p
}

func (x MediaUrlType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MediaUrlType) Descriptor() protoreflect.EnumDescriptor {
	return file_media_proto_enumTypes[8].Descriptor()
}

func (MediaUrlType) Type() protoreflect.EnumType {
	return &file_media_proto_enumTypes[8]
}

func (x MediaUrlType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MediaUrlType.Descriptor instead.
func (MediaUrlType) EnumDescriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{8}
}

type Metadata_MediaType int32

const (
	Metadata_MediaType_META_DATA_MEDIA_TYPE_IMAGE Metadata_MediaType = 0
	Metadata_MediaType_META_DATA_MEDIA_TYPE_VIDEO Metadata_MediaType = 1
	Metadata_MediaType_META_DATA_MEDIA_TYPE_GIF   Metadata_MediaType = 2
	Metadata_MediaType_META_DATA_MEDIA_TYPE_AUDIO Metadata_MediaType = 3
	// *
	// UNKNOWN - Some legacy messages do not specify a media type - rather than make an assumption about what they are; we model them explicitly as UNKNOWN.
	// New messages should absolutely not use this value.
	Metadata_MediaType_META_DATA_MEDIA_TYPE_UNKNOWN Metadata_MediaType = 4
)

// Enum value maps for Metadata_MediaType.
var (
	Metadata_MediaType_name = map[int32]string{
		0: "META_DATA_MEDIA_TYPE_IMAGE",
		1: "META_DATA_MEDIA_TYPE_VIDEO",
		2: "META_DATA_MEDIA_TYPE_GIF",
		3: "META_DATA_MEDIA_TYPE_AUDIO",
		4: "META_DATA_MEDIA_TYPE_UNKNOWN",
	}
	Metadata_MediaType_value = map[string]int32{
		"META_DATA_MEDIA_TYPE_IMAGE":   0,
		"META_DATA_MEDIA_TYPE_VIDEO":   1,
		"META_DATA_MEDIA_TYPE_GIF":     2,
		"META_DATA_MEDIA_TYPE_AUDIO":   3,
		"META_DATA_MEDIA_TYPE_UNKNOWN": 4,
	}
)

func (x Metadata_MediaType) Enum() *Metadata_MediaType {
	p := new(Metadata_MediaType)
	*p = x
	return p
}

func (x Metadata_MediaType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Metadata_MediaType) Descriptor() protoreflect.EnumDescriptor {
	return file_media_proto_enumTypes[9].Descriptor()
}

func (Metadata_MediaType) Type() protoreflect.EnumType {
	return &file_media_proto_enumTypes[9]
}

func (x Metadata_MediaType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Metadata_MediaType.Descriptor instead.
func (Metadata_MediaType) EnumDescriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{9}
}

// *
// DEPRECATED. Please use DisplayOrientation to specify the display orientation.
// Orientation for display on the client. Defaults to VERTICAL.
// Need to continue being populated for supporting backward compatibility.
type Orientation int32

const (
	Orientation_ORIENTATION_VERTICAL   Orientation = 0
	Orientation_ORIENTATION_HORIZONTAL Orientation = 1
)

// Enum value maps for Orientation.
var (
	Orientation_name = map[int32]string{
		0: "ORIENTATION_VERTICAL",
		1: "ORIENTATION_HORIZONTAL",
	}
	Orientation_value = map[string]int32{
		"ORIENTATION_VERTICAL":   0,
		"ORIENTATION_HORIZONTAL": 1,
	}
)

func (x Orientation) Enum() *Orientation {
	p := new(Orientation)
	*p = x
	return p
}

func (x Orientation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Orientation) Descriptor() protoreflect.EnumDescriptor {
	return file_media_proto_enumTypes[10].Descriptor()
}

func (Orientation) Type() protoreflect.EnumType {
	return &file_media_proto_enumTypes[10]
}

func (x Orientation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Orientation.Descriptor instead.
func (Orientation) EnumDescriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{10}
}

type DisplayOrientation int32

const (
	DisplayOrientation_DISPLAY_ORIENTATION_UNSET DisplayOrientation = 0
	// * UP - The original pixel data matches the media's intended display orientation.
	DisplayOrientation_DISPLAY_ORIENTATION_UP DisplayOrientation = 1
	// * DOWN - Rotate the original pixel data by 180 degree to match the media's intended display orientation.
	DisplayOrientation_DISPLAY_ORIENTATION_DOWN DisplayOrientation = 2
	// * LEFT - Rotate the original pixel data by 90 degree counterclockwise to match the media's intended display orientation.
	DisplayOrientation_DISPLAY_ORIENTATION_LEFT DisplayOrientation = 3
	// * RIGHT - Rotate the original pixel data by 90 degree clockwise to match the media's intended display orientation.
	DisplayOrientation_DISPLAY_ORIENTATION_RIGHT DisplayOrientation = 4
	// * UP_MIRRORED - Horizontally flip the original pixel data to match the media's intended display orientation.
	DisplayOrientation_DISPLAY_ORIENTATION_UP_MIRRORED DisplayOrientation = 5
	// * DOWN_MIRRORED - Vertically flip the original pixel data to match the media's intended display orientation.
	DisplayOrientation_DISPLAY_ORIENTATION_DOWN_MIRRORED DisplayOrientation = 6
	// *
	// LEFT_MIRRORED - Rotate the original pixel data by 90 degree clockwise and
	// flip horizontally to match the media's intended display orientation.
	DisplayOrientation_DISPLAY_ORIENTATION_LEFT_MIRRORED DisplayOrientation = 7
	// *
	// RIGHT_MIRRORED - Rotate the original pixel data by 90 degree counterclockwise and
	// flip horizontally to match the media's intended display orientation.
	DisplayOrientation_DISPLAY_ORIENTATION_RIGHT_MIRRORED DisplayOrientation = 8
)

// Enum value maps for DisplayOrientation.
var (
	DisplayOrientation_name = map[int32]string{
		0: "DISPLAY_ORIENTATION_UNSET",
		1: "DISPLAY_ORIENTATION_UP",
		2: "DISPLAY_ORIENTATION_DOWN",
		3: "DISPLAY_ORIENTATION_LEFT",
		4: "DISPLAY_ORIENTATION_RIGHT",
		5: "DISPLAY_ORIENTATION_UP_MIRRORED",
		6: "DISPLAY_ORIENTATION_DOWN_MIRRORED",
		7: "DISPLAY_ORIENTATION_LEFT_MIRRORED",
		8: "DISPLAY_ORIENTATION_RIGHT_MIRRORED",
	}
	DisplayOrientation_value = map[string]int32{
		"DISPLAY_ORIENTATION_UNSET":          0,
		"DISPLAY_ORIENTATION_UP":             1,
		"DISPLAY_ORIENTATION_DOWN":           2,
		"DISPLAY_ORIENTATION_LEFT":           3,
		"DISPLAY_ORIENTATION_RIGHT":          4,
		"DISPLAY_ORIENTATION_UP_MIRRORED":    5,
		"DISPLAY_ORIENTATION_DOWN_MIRRORED":  6,
		"DISPLAY_ORIENTATION_LEFT_MIRRORED":  7,
		"DISPLAY_ORIENTATION_RIGHT_MIRRORED": 8,
	}
)

func (x DisplayOrientation) Enum() *DisplayOrientation {
	p := new(DisplayOrientation)
	*p = x
	return p
}

func (x DisplayOrientation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DisplayOrientation) Descriptor() protoreflect.EnumDescriptor {
	return file_media_proto_enumTypes[11].Descriptor()
}

func (DisplayOrientation) Type() protoreflect.EnumType {
	return &file_media_proto_enumTypes[11]
}

func (x DisplayOrientation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DisplayOrientation.Descriptor instead.
func (DisplayOrientation) EnumDescriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{11}
}

type MediaMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Type             Metadata_MediaType             `protobuf:"varint,2,opt,name=type,proto3,enum=media.Metadata_MediaType" json:"type,omitempty"`
	Orientation      Orientation                    `protobuf:"varint,3,opt,name=orientation,proto3,enum=media.Orientation" json:"orientation,omitempty"`
	EncryptionInfoV1 *MediaEncryptionInfo           `protobuf:"bytes,4,opt,name=encryptionInfoV1,proto3" json:"encryptionInfoV1,omitempty"`
	Dimensions       *MediaMetadata_MediaDimensions `protobuf:"bytes,5,opt,name=dimensions,proto3" json:"dimensions,omitempty"`
	// *
	// Media duration for videos. This differs than the value in the Duration envelope;
	// which is about playback characteristics. E.g. for videos the Duration envelope might
	// contain "play_once"; whereas MediaMetadata.duration_ms might be 1230 ms.
	//
	// See duration.proto or playback_characteristics.proto for the full documentation of how this works.
	//
	// Clients can use this information to display:
	//  1. Total time information of a progress bar on the fullscreen video player (though
	//     that should really be based on the video itself; not this value)
	//  2. Show total time on media before it's clicked (this *should* use this information; to
	//     avoid having to download the media).
	//
	// TODO (@ricky-leatham): consider renaming "Duration" to something like "Playback"
	//
	// Types that are assignable to SourceMedia:
	//
	//	*MediaMetadata_LegacyMediaSource
	//	*MediaMetadata_ContentDescriptor
	SourceMedia            isMediaMetadata_SourceMedia `protobuf_oneof:"sourceMedia"`
	MediaUrl               string                      `protobuf:"bytes,9,opt,name=mediaUrl,proto3" json:"mediaUrl,omitempty"`
	HasSound               bool                        `protobuf:"varint,12,opt,name=hasSound,proto3" json:"hasSound,omitempty"`
	Zipped                 bool                        `protobuf:"varint,13,opt,name=zipped,proto3" json:"zipped,omitempty"`
	FrontFacing            bool                        `protobuf:"varint,14,opt,name=frontFacing,proto3" json:"frontFacing,omitempty"`
	MediaReference         *MediaReference             `protobuf:"bytes,17,opt,name=mediaReference,proto3" json:"mediaReference,omitempty"`
	MediaId                *MediaId                    `protobuf:"bytes,18,opt,name=mediaId,proto3" json:"mediaId,omitempty"`
	EncryptionInfoV2       *MediaEncryptionInfo        `protobuf:"bytes,19,opt,name=encryptionInfoV2,proto3" json:"encryptionInfoV2,omitempty"`
	AssetType              AssetType                   `protobuf:"varint,20,opt,name=assetType,proto3,enum=common.AssetType" json:"assetType,omitempty"` // enum
	CaptureCharacteristics *CaptureCharacteristics     `protobuf:"bytes,21,opt,name=captureCharacteristics,proto3" json:"captureCharacteristics,omitempty"`
	DisplayOrientation     DisplayOrientation          `protobuf:"varint,22,opt,name=displayOrientation,proto3,enum=media.DisplayOrientation" json:"displayOrientation,omitempty"`
	Audio                  *AudioMetadata              `protobuf:"bytes,23,opt,name=audio,proto3" json:"audio,omitempty"`
	Image                  *ImageMetadata              `protobuf:"bytes,24,opt,name=image,proto3" json:"image,omitempty"`
	Video                  *VideoMetadata              `protobuf:"bytes,25,opt,name=video,proto3" json:"video,omitempty"`
}

func (x *MediaMetadata) Reset() {
	*x = MediaMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MediaMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MediaMetadata) ProtoMessage() {}

func (x *MediaMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MediaMetadata.ProtoReflect.Descriptor instead.
func (*MediaMetadata) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{0}
}

func (x *MediaMetadata) GetType() Metadata_MediaType {
	if x != nil {
		return x.Type
	}
	return Metadata_MediaType_META_DATA_MEDIA_TYPE_IMAGE
}

func (x *MediaMetadata) GetOrientation() Orientation {
	if x != nil {
		return x.Orientation
	}
	return Orientation_ORIENTATION_VERTICAL
}

func (x *MediaMetadata) GetEncryptionInfoV1() *MediaEncryptionInfo {
	if x != nil {
		return x.EncryptionInfoV1
	}
	return nil
}

func (x *MediaMetadata) GetDimensions() *MediaMetadata_MediaDimensions {
	if x != nil {
		return x.Dimensions
	}
	return nil
}

func (m *MediaMetadata) GetSourceMedia() isMediaMetadata_SourceMedia {
	if m != nil {
		return m.SourceMedia
	}
	return nil
}

func (x *MediaMetadata) GetLegacyMediaSource() *LegacyMediaSource {
	if x, ok := x.GetSourceMedia().(*MediaMetadata_LegacyMediaSource); ok {
		return x.LegacyMediaSource
	}
	return nil
}

func (x *MediaMetadata) GetContentDescriptor() []byte {
	if x, ok := x.GetSourceMedia().(*MediaMetadata_ContentDescriptor); ok {
		return x.ContentDescriptor
	}
	return nil
}

func (x *MediaMetadata) GetMediaUrl() string {
	if x != nil {
		return x.MediaUrl
	}
	return ""
}

func (x *MediaMetadata) GetHasSound() bool {
	if x != nil {
		return x.HasSound
	}
	return false
}

func (x *MediaMetadata) GetZipped() bool {
	if x != nil {
		return x.Zipped
	}
	return false
}

func (x *MediaMetadata) GetFrontFacing() bool {
	if x != nil {
		return x.FrontFacing
	}
	return false
}

func (x *MediaMetadata) GetMediaReference() *MediaReference {
	if x != nil {
		return x.MediaReference
	}
	return nil
}

func (x *MediaMetadata) GetMediaId() *MediaId {
	if x != nil {
		return x.MediaId
	}
	return nil
}

func (x *MediaMetadata) GetEncryptionInfoV2() *MediaEncryptionInfo {
	if x != nil {
		return x.EncryptionInfoV2
	}
	return nil
}

func (x *MediaMetadata) GetAssetType() AssetType {
	if x != nil {
		return x.AssetType
	}
	return AssetType_ASSET_TYPE_UNSET
}

func (x *MediaMetadata) GetCaptureCharacteristics() *CaptureCharacteristics {
	if x != nil {
		return x.CaptureCharacteristics
	}
	return nil
}

func (x *MediaMetadata) GetDisplayOrientation() DisplayOrientation {
	if x != nil {
		return x.DisplayOrientation
	}
	return DisplayOrientation_DISPLAY_ORIENTATION_UNSET
}

func (x *MediaMetadata) GetAudio() *AudioMetadata {
	if x != nil {
		return x.Audio
	}
	return nil
}

func (x *MediaMetadata) GetImage() *ImageMetadata {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *MediaMetadata) GetVideo() *VideoMetadata {
	if x != nil {
		return x.Video
	}
	return nil
}

type isMediaMetadata_SourceMedia interface {
	isMediaMetadata_SourceMedia()
}

type MediaMetadata_LegacyMediaSource struct {
	LegacyMediaSource *LegacyMediaSource `protobuf:"bytes,6,opt,name=legacyMediaSource,proto3,oneof"`
}

type MediaMetadata_ContentDescriptor struct {
	ContentDescriptor []byte `protobuf:"bytes,7,opt,name=contentDescriptor,proto3,oneof"`
}

func (*MediaMetadata_LegacyMediaSource) isMediaMetadata_SourceMedia() {}

func (*MediaMetadata_ContentDescriptor) isMediaMetadata_SourceMedia() {}

type MediaReferences struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MediaReferenceLists []*ContentEnvelope_MediaReferenceList `protobuf:"bytes,1,rep,name=mediaReferenceLists,proto3" json:"mediaReferenceLists,omitempty"`
}

func (x *MediaReferences) Reset() {
	*x = MediaReferences{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MediaReferences) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MediaReferences) ProtoMessage() {}

func (x *MediaReferences) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MediaReferences.ProtoReflect.Descriptor instead.
func (*MediaReferences) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{1}
}

func (x *MediaReferences) GetMediaReferenceLists() []*ContentEnvelope_MediaReferenceList {
	if x != nil {
		return x.MediaReferenceLists
	}
	return nil
}

type ContentEnvelope_MediaReferenceList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Reference []*MediaReference `protobuf:"bytes,1,rep,name=reference,proto3" json:"reference,omitempty"`
}

func (x *ContentEnvelope_MediaReferenceList) Reset() {
	*x = ContentEnvelope_MediaReferenceList{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ContentEnvelope_MediaReferenceList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContentEnvelope_MediaReferenceList) ProtoMessage() {}

func (x *ContentEnvelope_MediaReferenceList) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContentEnvelope_MediaReferenceList.ProtoReflect.Descriptor instead.
func (*ContentEnvelope_MediaReferenceList) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{2}
}

func (x *ContentEnvelope_MediaReferenceList) GetReference() []*MediaReference {
	if x != nil {
		return x.Reference
	}
	return nil
}

type AudioMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CodecFormat AudioCodecFormat `protobuf:"varint,1,opt,name=codecFormat,proto3,enum=media.AudioCodecFormat" json:"codecFormat,omitempty"` // enum
}

func (x *AudioMetadata) Reset() {
	*x = AudioMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AudioMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AudioMetadata) ProtoMessage() {}

func (x *AudioMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AudioMetadata.ProtoReflect.Descriptor instead.
func (*AudioMetadata) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{3}
}

func (x *AudioMetadata) GetCodecFormat() AudioCodecFormat {
	if x != nil {
		return x.CodecFormat
	}
	return AudioCodecFormat_AUDIO_CODEC_UNSET
}

type ImageMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CodecFormat ImageCodecFormat `protobuf:"varint,1,opt,name=codecFormat,proto3,enum=media.ImageCodecFormat" json:"codecFormat,omitempty"` // enum
}

func (x *ImageMetadata) Reset() {
	*x = ImageMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ImageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImageMetadata) ProtoMessage() {}

func (x *ImageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImageMetadata.ProtoReflect.Descriptor instead.
func (*ImageMetadata) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{4}
}

func (x *ImageMetadata) GetCodecFormat() ImageCodecFormat {
	if x != nil {
		return x.CodecFormat
	}
	return ImageCodecFormat_IMAGE_CODEC_UNSET
}

type VideoMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CodecFormat     VideoCodecFormat `protobuf:"varint,1,opt,name=codecFormat,proto3,enum=media.VideoCodecFormat" json:"codecFormat,omitempty"`        // enum
	ContainerFormat VideoFileFormat  `protobuf:"varint,2,opt,name=containerFormat,proto3,enum=media.VideoFileFormat" json:"containerFormat,omitempty"` // enum
}

func (x *VideoMetadata) Reset() {
	*x = VideoMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VideoMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoMetadata) ProtoMessage() {}

func (x *VideoMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoMetadata.ProtoReflect.Descriptor instead.
func (*VideoMetadata) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{5}
}

func (x *VideoMetadata) GetCodecFormat() VideoCodecFormat {
	if x != nil {
		return x.CodecFormat
	}
	return VideoCodecFormat_VIDEO_CODEC_UNSET
}

func (x *VideoMetadata) GetContainerFormat() VideoFileFormat {
	if x != nil {
		return x.ContainerFormat
	}
	return VideoFileFormat_VIDEO_FILE_UNSET
}

type CaptureCharacteristics struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	FlashOn     bool `protobuf:"varint,1,opt,name=flashOn,proto3" json:"flashOn,omitempty"`
	FrontFacing bool `protobuf:"varint,2,opt,name=frontFacing,proto3" json:"frontFacing,omitempty"`
}

func (x *CaptureCharacteristics) Reset() {
	*x = CaptureCharacteristics{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CaptureCharacteristics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CaptureCharacteristics) ProtoMessage() {}

func (x *CaptureCharacteristics) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CaptureCharacteristics.ProtoReflect.Descriptor instead.
func (*CaptureCharacteristics) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{6}
}

func (x *CaptureCharacteristics) GetFlashOn() bool {
	if x != nil {
		return x.FlashOn
	}
	return false
}

func (x *CaptureCharacteristics) GetFrontFacing() bool {
	if x != nil {
		return x.FrontFacing
	}
	return false
}

// * Height and width of the referenced
type MediaMetadata_MediaDimensions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Width  int32 `protobuf:"varint,1,opt,name=width,proto3" json:"width,omitempty"`
	Height int32 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
}

func (x *MediaMetadata_MediaDimensions) Reset() {
	*x = MediaMetadata_MediaDimensions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MediaMetadata_MediaDimensions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MediaMetadata_MediaDimensions) ProtoMessage() {}

func (x *MediaMetadata_MediaDimensions) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MediaMetadata_MediaDimensions.ProtoReflect.Descriptor instead.
func (*MediaMetadata_MediaDimensions) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{7}
}

func (x *MediaMetadata_MediaDimensions) GetWidth() int32 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *MediaMetadata_MediaDimensions) GetHeight() int32 {
	if x != nil {
		return x.Height
	}
	return 0
}

type ThumbnailInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MediaId                 *MediaId `protobuf:"bytes,1,opt,name=mediaId,proto3" json:"mediaId,omitempty"`
	MediaReferenceListIndex int32    `protobuf:"varint,2,opt,name=mediaReferenceListIndex,proto3" json:"mediaReferenceListIndex,omitempty"`
}

func (x *ThumbnailInfo) Reset() {
	*x = ThumbnailInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ThumbnailInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThumbnailInfo) ProtoMessage() {}

func (x *ThumbnailInfo) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThumbnailInfo.ProtoReflect.Descriptor instead.
func (*ThumbnailInfo) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{8}
}

func (x *ThumbnailInfo) GetMediaId() *MediaId {
	if x != nil {
		return x.MediaId
	}
	return nil
}

func (x *ThumbnailInfo) GetMediaReferenceListIndex() int32 {
	if x != nil {
		return x.MediaReferenceListIndex
	}
	return 0
}

type MediaId struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MediaListId uint64 `protobuf:"varint,1,opt,name=mediaListId,proto3" json:"mediaListId,omitempty"`
}

func (x *MediaId) Reset() {
	*x = MediaId{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MediaId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MediaId) ProtoMessage() {}

func (x *MediaId) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MediaId.ProtoReflect.Descriptor instead.
func (*MediaId) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{9}
}

func (x *MediaId) GetMediaListId() uint64 {
	if x != nil {
		return x.MediaListId
	}
	return 0
}

type MediaReference struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Url              string                       `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	ContentObject    []byte                       `protobuf:"bytes,3,opt,name=contentObject,proto3" json:"contentObject,omitempty"`
	VideoDescription *VideoDescription            `protobuf:"bytes,5,opt,name=videoDescription,proto3" json:"videoDescription,omitempty"`
	MediaListId      uint64                       `protobuf:"varint,6,opt,name=mediaListId,proto3" json:"mediaListId,omitempty"`
	ClaimBehavior    MediaReference_ClaimBehavior `protobuf:"varint,7,opt,name=claimBehavior,proto3,enum=media.MediaReference_ClaimBehavior" json:"claimBehavior,omitempty"`
	MediaType        MediaType                    `protobuf:"varint,8,opt,name=mediaType,proto3,enum=media.MediaType" json:"mediaType,omitempty"` // enum
	LocalContentKey  string                       `protobuf:"bytes,9,opt,name=localContentKey,proto3" json:"localContentKey,omitempty"`
	LocalCacheKey    string                       `protobuf:"bytes,10,opt,name=localCacheKey,proto3" json:"localCacheKey,omitempty"`
}

func (x *MediaReference) Reset() {
	*x = MediaReference{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MediaReference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MediaReference) ProtoMessage() {}

func (x *MediaReference) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MediaReference.ProtoReflect.Descriptor instead.
func (*MediaReference) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{10}
}

func (x *MediaReference) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *MediaReference) GetContentObject() []byte {
	if x != nil {
		return x.ContentObject
	}
	return nil
}

func (x *MediaReference) GetVideoDescription() *VideoDescription {
	if x != nil {
		return x.VideoDescription
	}
	return nil
}

func (x *MediaReference) GetMediaListId() uint64 {
	if x != nil {
		return x.MediaListId
	}
	return 0
}

func (x *MediaReference) GetClaimBehavior() MediaReference_ClaimBehavior {
	if x != nil {
		return x.ClaimBehavior
	}
	return MediaReference_ClaimBehavior_REFERENCE_CAN_EXTEND_MEDIA_CLAIM
}

func (x *MediaReference) GetMediaType() MediaType {
	if x != nil {
		return x.MediaType
	}
	return MediaType_MEDIA_TYPE_UNASSIGNED
}

func (x *MediaReference) GetLocalContentKey() string {
	if x != nil {
		return x.LocalContentKey
	}
	return ""
}

func (x *MediaReference) GetLocalCacheKey() string {
	if x != nil {
		return x.LocalCacheKey
	}
	return ""
}

type VideoDescription struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	VideoPlaybackType VideoDescription_VideoPlaybackType `protobuf:"varint,1,opt,name=videoPlaybackType,proto3,enum=media.VideoDescription_VideoPlaybackType" json:"videoPlaybackType,omitempty"`
	MediaQualityType  VideoDescription_MediaQualityType  `protobuf:"varint,2,opt,name=mediaQualityType,proto3,enum=media.VideoDescription_MediaQualityType" json:"mediaQualityType,omitempty"`
}

func (x *VideoDescription) Reset() {
	*x = VideoDescription{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VideoDescription) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoDescription) ProtoMessage() {}

func (x *VideoDescription) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoDescription.ProtoReflect.Descriptor instead.
func (*VideoDescription) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{11}
}

func (x *VideoDescription) GetVideoPlaybackType() VideoDescription_VideoPlaybackType {
	if x != nil {
		return x.VideoPlaybackType
	}
	return VideoDescription_VideoPlaybackType_VIDEO_UNKNOWN_PLAYBACK_TYPE
}

func (x *VideoDescription) GetMediaQualityType() VideoDescription_MediaQualityType {
	if x != nil {
		return x.MediaQualityType
	}
	return VideoDescription_MediaQualityType_VIDEO_MEDIA_QUALITY_TYPE_UNKNOWN
}

type LegacyMediaSource struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SourceMediaId     string                   `protobuf:"bytes,1,opt,name=sourceMediaId,proto3" json:"sourceMediaId,omitempty"`
	DirectDownloadUrl *LegacyDirectDownloadUrl `protobuf:"bytes,2,opt,name=directDownloadUrl,proto3" json:"directDownloadUrl,omitempty"`
}

func (x *LegacyMediaSource) Reset() {
	*x = LegacyMediaSource{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LegacyMediaSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LegacyMediaSource) ProtoMessage() {}

func (x *LegacyMediaSource) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LegacyMediaSource.ProtoReflect.Descriptor instead.
func (*LegacyMediaSource) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{12}
}

func (x *LegacyMediaSource) GetSourceMediaId() string {
	if x != nil {
		return x.SourceMediaId
	}
	return ""
}

func (x *LegacyMediaSource) GetDirectDownloadUrl() *LegacyDirectDownloadUrl {
	if x != nil {
		return x.DirectDownloadUrl
	}
	return nil
}

type LegacyDirectDownloadUrl struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Url           string       `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	ExpirySeconds uint64       `protobuf:"varint,2,opt,name=expirySeconds,proto3" json:"expirySeconds,omitempty"`
	Type          MediaUrlType `protobuf:"varint,3,opt,name=type,proto3,enum=media.MediaUrlType" json:"type,omitempty"`
	Region        string       `protobuf:"bytes,4,opt,name=region,proto3" json:"region,omitempty"`
}

func (x *LegacyDirectDownloadUrl) Reset() {
	*x = LegacyDirectDownloadUrl{}
	if protoimpl.UnsafeEnabled {
		mi := &file_media_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LegacyDirectDownloadUrl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LegacyDirectDownloadUrl) ProtoMessage() {}

func (x *LegacyDirectDownloadUrl) ProtoReflect() protoreflect.Message {
	mi := &file_media_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LegacyDirectDownloadUrl.ProtoReflect.Descriptor instead.
func (*LegacyDirectDownloadUrl) Descriptor() ([]byte, []int) {
	return file_media_proto_rawDescGZIP(), []int{13}
}

func (x *LegacyDirectDownloadUrl) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *LegacyDirectDownloadUrl) GetExpirySeconds() uint64 {
	if x != nil {
		return x.ExpirySeconds
	}
	return 0
}

func (x *LegacyDirectDownloadUrl) GetType() MediaUrlType {
	if x != nil {
		return x.Type
	}
	return MediaUrlType_MEDIA_URL_TYPE_GCS
}

func (x *LegacyDirectDownloadUrl) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

var File_media_proto protoreflect.FileDescriptor

var file_media_proto_rawDesc = []byte{
	0x0a, 0x0b, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05, 0x6d,
	0x65, 0x64, 0x69, 0x61, 0x1a, 0x0c, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x1a, 0x0c, 0x63, 0x72, 0x79, 0x70, 0x74, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x22, 0x87, 0x08, 0x0a, 0x0d, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61,
	0x74, 0x61, 0x12, 0x2d, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x19, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
	0x61, 0x5f, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70,
	0x65, 0x12, 0x34, 0x0a, 0x0b, 0x6f, 0x72, 0x69, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x4f,
	0x72, 0x69, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0b, 0x6f, 0x72, 0x69, 0x65,
	0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x47, 0x0a, 0x10, 0x65, 0x6e, 0x63, 0x72, 0x79,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x56, 0x31, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x6f, 0x2e, 0x4d, 0x65, 0x64, 0x69, 0x61,
	0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x10,
	0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x56, 0x31,
	0x12, 0x44, 0x0a, 0x0a, 0x64, 0x69, 0x6d, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x4d, 0x65, 0x64,
	0x69, 0x61, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x4d, 0x65, 0x64, 0x69, 0x61,
	0x44, 0x69, 0x6d, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x0a, 0x64, 0x69, 0x6d, 0x65,
	0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x48, 0x0a, 0x11, 0x6c, 0x65, 0x67, 0x61, 0x63, 0x79,
	0x4d, 0x65, 0x64, 0x69, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79,
	0x4d, 0x65, 0x64, 0x69, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x48, 0x00, 0x52, 0x11, 0x6c,
	0x65, 0x67, 0x61, 0x63, 0x79, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65,
	0x12, 0x2e, 0x0a, 0x11, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x44, 0x65, 0x73, 0x63, 0x72,
	0x69, 0x70, 0x74, 0x6f, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x11, 0x63,
	0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72,
	0x12, 0x1a, 0x0a, 0x08, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x55, 0x72, 0x6c, 0x18, 0x09, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x08, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x55, 0x72, 0x6c, 0x12, 0x1a, 0x0a, 0x08,
	0x68, 0x61, 0x73, 0x53, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08,
	0x68, 0x61, 0x73, 0x53, 0x6f, 0x75, 0x6e, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x7a, 0x69, 0x70, 0x70,
	0x65, 0x64, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x7a, 0x69, 0x70, 0x70, 0x65, 0x64,
	0x12, 0x20, 0x0a, 0x0b, 0x66, 0x72, 0x6f, 0x6e, 0x74, 0x46, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x18,
	0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x66, 0x72, 0x6f, 0x6e, 0x74, 0x46, 0x61, 0x63, 0x69,
	0x6e, 0x67, 0x12, 0x3d, 0x0a, 0x0e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x52, 0x65, 0x66, 0x65, 0x72,
	0x65, 0x6e, 0x63, 0x65, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x64,
	0x69, 0x61, 0x2e, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63,
	0x65, 0x52, 0x0e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63,
	0x65, 0x12, 0x28, 0x0a, 0x07, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x49, 0x64, 0x18, 0x12, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x4d, 0x65, 0x64, 0x69, 0x61,
	0x49, 0x64, 0x52, 0x07, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x49, 0x64, 0x12, 0x47, 0x0a, 0x10, 0x65,
	0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x56, 0x32, 0x18,
	0x13, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x6f, 0x2e, 0x4d,
	0x65, 0x64, 0x69, 0x61, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e,
	0x66, 0x6f, 0x52, 0x10, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e,
	0x66, 0x6f, 0x56, 0x32, 0x12, 0x2f, 0x0a, 0x09, 0x61, 0x73, 0x73, 0x65, 0x74, 0x54, 0x79, 0x70,
	0x65, 0x18, 0x14, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x11, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x09, 0x61, 0x73, 0x73, 0x65,
	0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x55, 0x0a, 0x16, 0x63, 0x61, 0x70, 0x74, 0x75, 0x72, 0x65,
	0x43, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x18,
	0x15, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x43, 0x61,
	0x70, 0x74, 0x75, 0x72, 0x65, 0x43, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x69, 0x73,
	0x74, 0x69, 0x63, 0x73, 0x52, 0x16, 0x63, 0x61, 0x70, 0x74, 0x75, 0x72, 0x65, 0x43, 0x68, 0x61,
	0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x49, 0x0a, 0x12,
	0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4f, 0x72, 0x69, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x16, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61,
	0x2e, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4f, 0x72, 0x69, 0x65, 0x6e, 0x74, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x52, 0x12, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4f, 0x72, 0x69, 0x65,
	0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2a, 0x0a, 0x05, 0x61, 0x75, 0x64, 0x69, 0x6f,
	0x18, 0x17, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x41,
	0x75, 0x64, 0x69, 0x6f, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x05, 0x61, 0x75,
	0x64, 0x69, 0x6f, 0x12, 0x2a, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x18, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65,
	0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x12,
	0x2a, 0x0a, 0x05, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x18, 0x19, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14,
	0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x52, 0x05, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x42, 0x0d, 0x0a, 0x0b, 0x73,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x22, 0x6e, 0x0a, 0x0f, 0x4d, 0x65,
	0x64, 0x69, 0x61, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x5b, 0x0a,
	0x13, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x4c,
	0x69, 0x73, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x6d, 0x65, 0x64,
	0x69, 0x61, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x76, 0x65, 0x6c, 0x6f,
	0x70, 0x65, 0x5f, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63,
	0x65, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x13, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x52, 0x65, 0x66, 0x65,
	0x72, 0x65, 0x6e, 0x63, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x73, 0x22, 0x59, 0x0a, 0x22, 0x43, 0x6f,
	0x6e, 0x74, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x76, 0x65, 0x6c, 0x6f, 0x70, 0x65, 0x5f, 0x4d, 0x65,
	0x64, 0x69, 0x61, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x4c, 0x69, 0x73, 0x74,
	0x12, 0x33, 0x0a, 0x09, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x4d, 0x65, 0x64, 0x69,
	0x61, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x52, 0x09, 0x72, 0x65, 0x66, 0x65,
	0x72, 0x65, 0x6e, 0x63, 0x65, 0x22, 0x4a, 0x0a, 0x0d, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x4d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x39, 0x0a, 0x0b, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x46,
	0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x17, 0x2e, 0x6d, 0x65,
	0x64, 0x69, 0x61, 0x2e, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x46, 0x6f,
	0x72, 0x6d, 0x61, 0x74, 0x52, 0x0b, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x46, 0x6f, 0x72, 0x6d, 0x61,
	0x74, 0x22, 0x4a, 0x0a, 0x0d, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61,
	0x74, 0x61, 0x12, 0x39, 0x0a, 0x0b, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x46, 0x6f, 0x72, 0x6d, 0x61,
	0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x17, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74,
	0x52, 0x0b, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x22, 0x8c, 0x01,
	0x0a, 0x0d, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12,
	0x39, 0x0a, 0x0b, 0x63, 0x6f, 0x64, 0x65, 0x63, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x17, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x56, 0x69, 0x64,
	0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52, 0x0b, 0x63,
	0x6f, 0x64, 0x65, 0x63, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x40, 0x0a, 0x0f, 0x63, 0x6f,
	0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x56, 0x69, 0x64, 0x65,
	0x6f, 0x46, 0x69, 0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52, 0x0f, 0x63, 0x6f, 0x6e,
	0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x22, 0x54, 0x0a, 0x16,
	0x43, 0x61, 0x70, 0x74, 0x75, 0x72, 0x65, 0x43, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72,
	0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x66, 0x6c, 0x61, 0x73, 0x68, 0x4f,
	0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x66, 0x6c, 0x61, 0x73, 0x68, 0x4f, 0x6e,
	0x12, 0x20, 0x0a, 0x0b, 0x66, 0x72, 0x6f, 0x6e, 0x74, 0x46, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x66, 0x72, 0x6f, 0x6e, 0x74, 0x46, 0x61, 0x63, 0x69,
	0x6e, 0x67, 0x22, 0x4d, 0x0a, 0x1d, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x4d, 0x65, 0x74, 0x61, 0x64,
	0x61, 0x74, 0x61, 0x5f, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x44, 0x69, 0x6d, 0x65, 0x6e, 0x73, 0x69,
	0x6f, 0x6e, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x12, 0x16, 0x0a, 0x06, 0x68, 0x65, 0x69,
	0x67, 0x68, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68,
	0x74, 0x22, 0x73, 0x0a, 0x0d, 0x54, 0x68, 0x75, 0x6d, 0x62, 0x6e, 0x61, 0x69, 0x6c, 0x49, 0x6e,
	0x66, 0x6f, 0x12, 0x28, 0x0a, 0x07, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x49, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x4d, 0x65, 0x64, 0x69,
	0x61, 0x49, 0x64, 0x52, 0x07, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x49, 0x64, 0x12, 0x38, 0x0a, 0x17,
	0x6d, 0x65, 0x64, 0x69, 0x61, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x4c, 0x69,
	0x73, 0x74, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x17, 0x6d,
	0x65, 0x64, 0x69, 0x61, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x4c, 0x69, 0x73,
	0x74, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x22, 0x2b, 0x0a, 0x07, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x49,
	0x64, 0x12, 0x20, 0x0a, 0x0b, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x4c, 0x69, 0x73,
	0x74, 0x49, 0x64, 0x22, 0xfa, 0x02, 0x0a, 0x0e, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x52, 0x65, 0x66,
	0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x24, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74,
	0x65, 0x6e, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x43,
	0x0a, 0x10, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61,
	0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
	0x6e, 0x52, 0x10, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x69, 0x6f, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x4c, 0x69, 0x73, 0x74,
	0x49, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x4c,
	0x69, 0x73, 0x74, 0x49, 0x64, 0x12, 0x49, 0x0a, 0x0d, 0x63, 0x6c, 0x61, 0x69, 0x6d, 0x42, 0x65,
	0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x23, 0x2e, 0x6d,
	0x65, 0x64, 0x69, 0x61, 0x2e, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65,
	0x6e, 0x63, 0x65, 0x5f, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x42, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f,
	0x72, 0x52, 0x0d, 0x63, 0x6c, 0x61, 0x69, 0x6d, 0x42, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72,
	0x12, 0x2e, 0x0a, 0x09, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x54, 0x79, 0x70, 0x65, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x4d, 0x65, 0x64, 0x69,
	0x61, 0x54, 0x79, 0x70, 0x65, 0x52, 0x09, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x54, 0x79, 0x70, 0x65,
	0x12, 0x28, 0x0a, 0x0f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74,
	0x4b, 0x65, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x6c, 0x6f, 0x63, 0x61, 0x6c,
	0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x4b, 0x65, 0x79, 0x12, 0x24, 0x0a, 0x0d, 0x6c, 0x6f,
	0x63, 0x61, 0x6c, 0x43, 0x61, 0x63, 0x68, 0x65, 0x4b, 0x65, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x0d, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x43, 0x61, 0x63, 0x68, 0x65, 0x4b, 0x65, 0x79,
	0x22, 0xc1, 0x01, 0x0a, 0x10, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x57, 0x0a, 0x11, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x50, 0x6c,
	0x61, 0x79, 0x62, 0x61, 0x63, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x29, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x44, 0x65,
	0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x50,
	0x6c, 0x61, 0x79, 0x62, 0x61, 0x63, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x52, 0x11, 0x76, 0x69, 0x64,
	0x65, 0x6f, 0x50, 0x6c, 0x61, 0x79, 0x62, 0x61, 0x63, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x12, 0x54,
	0x0a, 0x10, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x51, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x54, 0x79,
	0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x28, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61,
	0x2e, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
	0x6e, 0x5f, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x51, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x54, 0x79,
	0x70, 0x65, 0x52, 0x10, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x51, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79,
	0x54, 0x79, 0x70, 0x65, 0x22, 0x87, 0x01, 0x0a, 0x11, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x4d,
	0x65, 0x64, 0x69, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x24, 0x0a, 0x0d, 0x73, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x49, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x0d, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x49, 0x64,
	0x12, 0x4c, 0x0a, 0x11, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f,
	0x61, 0x64, 0x55, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x6d, 0x65,
	0x64, 0x69, 0x61, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74,
	0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x55, 0x72, 0x6c, 0x52, 0x11, 0x64, 0x69, 0x72,
	0x65, 0x63, 0x74, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x55, 0x72, 0x6c, 0x22, 0x92,
	0x01, 0x0a, 0x17, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x44,
	0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x55, 0x72, 0x6c, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72,
	0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x24, 0x0a, 0x0d,
	0x65, 0x78, 0x70, 0x69, 0x72, 0x79, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x0d, 0x65, 0x78, 0x70, 0x69, 0x72, 0x79, 0x53, 0x65, 0x63, 0x6f, 0x6e,
	0x64, 0x73, 0x12, 0x27, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x13, 0x2e, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x55, 0x72,
	0x6c, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x72,
	0x65, 0x67, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x65, 0x67,
	0x69, 0x6f, 0x6e, 0x2a, 0x60, 0x0a, 0x1c, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x52, 0x65, 0x66, 0x65,
	0x72, 0x65, 0x6e, 0x63, 0x65, 0x5f, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x42, 0x65, 0x68, 0x61, 0x76,
	0x69, 0x6f, 0x72, 0x12, 0x24, 0x0a, 0x20, 0x52, 0x45, 0x46, 0x45, 0x52, 0x45, 0x4e, 0x43, 0x45,
	0x5f, 0x43, 0x41, 0x4e, 0x5f, 0x45, 0x58, 0x54, 0x45, 0x4e, 0x44, 0x5f, 0x4d, 0x45, 0x44, 0x49,
	0x41, 0x5f, 0x43, 0x4c, 0x41, 0x49, 0x4d, 0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16, 0x52, 0x45, 0x46,
	0x45, 0x52, 0x45, 0x4e, 0x43, 0x45, 0x5f, 0x44, 0x4f, 0x5f, 0x4e, 0x4f, 0x54, 0x5f, 0x43, 0x4c,
	0x41, 0x49, 0x4d, 0x10, 0x01, 0x2a, 0xbd, 0x01, 0x0a, 0x22, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x44,
	0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x56, 0x69, 0x64, 0x65, 0x6f,
	0x50, 0x6c, 0x61, 0x79, 0x62, 0x61, 0x63, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1f, 0x0a, 0x1b,
	0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x5f, 0x50, 0x4c,
	0x41, 0x59, 0x42, 0x41, 0x43, 0x4b, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x10, 0x00, 0x12, 0x1c, 0x0a,
	0x18, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x46, 0x41, 0x53, 0x54, 0x53, 0x54, 0x41, 0x52, 0x54,
	0x5f, 0x44, 0x49, 0x53, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x10, 0x01, 0x12, 0x1b, 0x0a, 0x17, 0x56,
	0x49, 0x44, 0x45, 0x4f, 0x5f, 0x46, 0x41, 0x53, 0x54, 0x53, 0x54, 0x41, 0x52, 0x54, 0x5f, 0x45,
	0x4e, 0x41, 0x42, 0x4c, 0x45, 0x44, 0x10, 0x02, 0x12, 0x1d, 0x0a, 0x19, 0x56, 0x49, 0x44, 0x45,
	0x4f, 0x5f, 0x48, 0x54, 0x54, 0x50, 0x5f, 0x53, 0x54, 0x52, 0x45, 0x41, 0x4d, 0x49, 0x4e, 0x47,
	0x5f, 0x44, 0x41, 0x53, 0x48, 0x10, 0x03, 0x12, 0x1c, 0x0a, 0x18, 0x56, 0x49, 0x44, 0x45, 0x4f,
	0x5f, 0x48, 0x54, 0x54, 0x50, 0x5f, 0x53, 0x54, 0x52, 0x45, 0x41, 0x4d, 0x49, 0x4e, 0x47, 0x5f,
	0x48, 0x4c, 0x53, 0x10, 0x04, 0x2a, 0xca, 0x05, 0x0a, 0x21, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x44,
	0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x4d, 0x65, 0x64, 0x69, 0x61,
	0x51, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x54, 0x79, 0x70, 0x65, 0x12, 0x24, 0x0a, 0x20, 0x56,
	0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x51, 0x55, 0x41, 0x4c, 0x49,
	0x54, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10,
	0x00, 0x12, 0x24, 0x0a, 0x20, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41,
	0x5f, 0x51, 0x55, 0x41, 0x4c, 0x49, 0x54, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x45,
	0x56, 0x45, 0x4c, 0x5f, 0x31, 0x10, 0x64, 0x12, 0x25, 0x0a, 0x20, 0x56, 0x49, 0x44, 0x45, 0x4f,
	0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x51, 0x55, 0x41, 0x4c, 0x49, 0x54, 0x59, 0x5f, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x5f, 0x32, 0x10, 0xc8, 0x01, 0x12, 0x25,
	0x0a, 0x20, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x51, 0x55,
	0x41, 0x4c, 0x49, 0x54, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c,
	0x5f, 0x33, 0x10, 0xac, 0x02, 0x12, 0x25, 0x0a, 0x20, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4d,
	0x45, 0x44, 0x49, 0x41, 0x5f, 0x51, 0x55, 0x41, 0x4c, 0x49, 0x54, 0x59, 0x5f, 0x54, 0x59, 0x50,
	0x45, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x5f, 0x34, 0x10, 0x90, 0x03, 0x12, 0x25, 0x0a, 0x20,
	0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x51, 0x55, 0x41, 0x4c,
	0x49, 0x54, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x5f, 0x35,
	0x10, 0xf4, 0x03, 0x12, 0x25, 0x0a, 0x20, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44,
	0x49, 0x41, 0x5f, 0x51, 0x55, 0x41, 0x4c, 0x49, 0x54, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x4c, 0x45, 0x56, 0x45, 0x4c, 0x5f, 0x36, 0x10, 0xd8, 0x04, 0x12, 0x25, 0x0a, 0x20, 0x56, 0x49,
	0x44, 0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x51, 0x55, 0x41, 0x4c, 0x49, 0x54,
	0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x5f, 0x37, 0x10, 0xbc,
	0x05, 0x12, 0x27, 0x0a, 0x22, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41,
	0x5f, 0x51, 0x55, 0x41, 0x4c, 0x49, 0x54, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x45,
	0x56, 0x45, 0x4c, 0x5f, 0x4d, 0x41, 0x58, 0x10, 0x88, 0x27, 0x12, 0x27, 0x0a, 0x22, 0x56, 0x49,
	0x44, 0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x51, 0x55, 0x41, 0x4c, 0x49, 0x54,
	0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x5f, 0x34, 0x5f, 0x35,
	0x10, 0xc2, 0x03, 0x12, 0x27, 0x0a, 0x22, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44,
	0x49, 0x41, 0x5f, 0x51, 0x55, 0x41, 0x4c, 0x49, 0x54, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x4c, 0x45, 0x56, 0x45, 0x4c, 0x5f, 0x32, 0x5f, 0x31, 0x10, 0xd2, 0x01, 0x12, 0x27, 0x0a, 0x22,
	0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x51, 0x55, 0x41, 0x4c,
	0x49, 0x54, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x5f, 0x32,
	0x5f, 0x32, 0x10, 0xdc, 0x01, 0x12, 0x27, 0x0a, 0x22, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4d,
	0x45, 0x44, 0x49, 0x41, 0x5f, 0x51, 0x55, 0x41, 0x4c, 0x49, 0x54, 0x59, 0x5f, 0x54, 0x59, 0x50,
	0x45, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x5f, 0x32, 0x5f, 0x35, 0x10, 0xfa, 0x01, 0x12, 0x27,
	0x0a, 0x22, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x51, 0x55,
	0x41, 0x4c, 0x49, 0x54, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c,
	0x5f, 0x33, 0x5f, 0x32, 0x10, 0xc0, 0x02, 0x12, 0x27, 0x0a, 0x22, 0x56, 0x49, 0x44, 0x45, 0x4f,
	0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x51, 0x55, 0x41, 0x4c, 0x49, 0x54, 0x59, 0x5f, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x5f, 0x33, 0x5f, 0x35, 0x10, 0xde, 0x02,
	0x12, 0x27, 0x0a, 0x22, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f,
	0x51, 0x55, 0x41, 0x4c, 0x49, 0x54, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x45, 0x56,
	0x45, 0x4c, 0x5f, 0x32, 0x5f, 0x37, 0x10, 0x8e, 0x02, 0x12, 0x27, 0x0a, 0x22, 0x56, 0x49, 0x44,
	0x45, 0x4f, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x51, 0x55, 0x41, 0x4c, 0x49, 0x54, 0x59,
	0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x5f, 0x36, 0x5f, 0x35, 0x10,
	0x8a, 0x05, 0x2a, 0x50, 0x0a, 0x0f, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x46, 0x69, 0x6c, 0x65, 0x46,
	0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x14, 0x0a, 0x10, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x46,
	0x49, 0x4c, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10, 0x00, 0x12, 0x12, 0x0a, 0x0e, 0x56,
	0x49, 0x44, 0x45, 0x4f, 0x5f, 0x46, 0x49, 0x4c, 0x45, 0x5f, 0x4d, 0x50, 0x34, 0x10, 0x01, 0x12,
	0x13, 0x0a, 0x0f, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x46, 0x49, 0x4c, 0x45, 0x5f, 0x46, 0x4d,
	0x50, 0x34, 0x10, 0x02, 0x2a, 0x6b, 0x0a, 0x10, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x64,
	0x65, 0x63, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x15, 0x0a, 0x11, 0x41, 0x55, 0x44, 0x49,
	0x4f, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x43, 0x5f, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10, 0x00, 0x12,
	0x13, 0x0a, 0x0f, 0x41, 0x55, 0x44, 0x49, 0x4f, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x43, 0x5f, 0x41,
	0x41, 0x43, 0x10, 0x01, 0x12, 0x15, 0x0a, 0x11, 0x41, 0x55, 0x44, 0x49, 0x4f, 0x5f, 0x43, 0x4f,
	0x44, 0x45, 0x43, 0x5f, 0x48, 0x45, 0x41, 0x41, 0x43, 0x10, 0x02, 0x12, 0x14, 0x0a, 0x10, 0x41,
	0x55, 0x44, 0x49, 0x4f, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x43, 0x5f, 0x4f, 0x50, 0x55, 0x53, 0x10,
	0x03, 0x2a, 0xac, 0x01, 0x0a, 0x10, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x64, 0x65, 0x63,
	0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x15, 0x0a, 0x11, 0x49, 0x4d, 0x41, 0x47, 0x45, 0x5f,
	0x43, 0x4f, 0x44, 0x45, 0x43, 0x5f, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10, 0x00, 0x12, 0x14, 0x0a,
	0x10, 0x49, 0x4d, 0x41, 0x47, 0x45, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x43, 0x5f, 0x4a, 0x50, 0x45,
	0x47, 0x10, 0x01, 0x12, 0x13, 0x0a, 0x0f, 0x49, 0x4d, 0x41, 0x47, 0x45, 0x5f, 0x43, 0x4f, 0x44,
	0x45, 0x43, 0x5f, 0x50, 0x4e, 0x47, 0x10, 0x02, 0x12, 0x14, 0x0a, 0x10, 0x49, 0x4d, 0x41, 0x47,
	0x45, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x43, 0x5f, 0x57, 0x45, 0x42, 0x50, 0x10, 0x03, 0x12, 0x14,
	0x0a, 0x10, 0x49, 0x4d, 0x41, 0x47, 0x45, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x43, 0x5f, 0x48, 0x45,
	0x49, 0x46, 0x10, 0x04, 0x12, 0x15, 0x0a, 0x11, 0x49, 0x4d, 0x41, 0x47, 0x45, 0x5f, 0x43, 0x4f,
	0x44, 0x45, 0x43, 0x5f, 0x41, 0x57, 0x45, 0x42, 0x50, 0x10, 0x05, 0x12, 0x13, 0x0a, 0x0f, 0x49,
	0x4d, 0x41, 0x47, 0x45, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x43, 0x5f, 0x47, 0x49, 0x46, 0x10, 0x06,
	0x2a, 0x7f, 0x0a, 0x10, 0x56, 0x69, 0x64, 0x65, 0x6f, 0x43, 0x6f, 0x64, 0x65, 0x63, 0x46, 0x6f,
	0x72, 0x6d, 0x61, 0x74, 0x12, 0x15, 0x0a, 0x11, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x43, 0x4f,
	0x44, 0x45, 0x43, 0x5f, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10, 0x00, 0x12, 0x14, 0x0a, 0x10, 0x56,
	0x49, 0x44, 0x45, 0x4f, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x43, 0x5f, 0x48, 0x32, 0x36, 0x34, 0x10,
	0x01, 0x12, 0x14, 0x0a, 0x10, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x43,
	0x5f, 0x48, 0x45, 0x56, 0x43, 0x10, 0x02, 0x12, 0x13, 0x0a, 0x0f, 0x56, 0x49, 0x44, 0x45, 0x4f,
	0x5f, 0x43, 0x4f, 0x44, 0x45, 0x43, 0x5f, 0x41, 0x56, 0x31, 0x10, 0x03, 0x12, 0x13, 0x0a, 0x0f,
	0x56, 0x49, 0x44, 0x45, 0x4f, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x43, 0x5f, 0x56, 0x50, 0x39, 0x10,
	0x04, 0x2a, 0xbe, 0x02, 0x0a, 0x09, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x54, 0x79, 0x70, 0x65, 0x12,
	0x19, 0x0a, 0x15, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e,
	0x41, 0x53, 0x53, 0x49, 0x47, 0x4e, 0x45, 0x44, 0x10, 0x00, 0x12, 0x16, 0x0a, 0x12, 0x4d, 0x45,
	0x44, 0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f, 0x56, 0x45, 0x52, 0x4c, 0x41, 0x59,
	0x10, 0x01, 0x12, 0x14, 0x0a, 0x10, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x49, 0x4d, 0x41, 0x47, 0x45, 0x10, 0x02, 0x12, 0x14, 0x0a, 0x10, 0x4d, 0x45, 0x44, 0x49,
	0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x10, 0x03, 0x12, 0x1a,
	0x0a, 0x16, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x53, 0x53,
	0x45, 0x54, 0x42, 0x55, 0x4e, 0x44, 0x4c, 0x45, 0x10, 0x04, 0x12, 0x14, 0x0a, 0x10, 0x4d, 0x45,
	0x44, 0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x55, 0x44, 0x49, 0x4f, 0x10, 0x05,
	0x12, 0x1c, 0x0a, 0x18, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41,
	0x4e, 0x49, 0x4d, 0x41, 0x54, 0x45, 0x44, 0x49, 0x4d, 0x41, 0x47, 0x45, 0x10, 0x06, 0x12, 0x13,
	0x0a, 0x0f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x46, 0x4f, 0x4e,
	0x54, 0x10, 0x07, 0x12, 0x1d, 0x0a, 0x19, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x54, 0x59, 0x50,
	0x45, 0x5f, 0x57, 0x45, 0x42, 0x56, 0x49, 0x45, 0x57, 0x43, 0x4f, 0x4e, 0x54, 0x45, 0x4e, 0x54,
	0x10, 0x08, 0x12, 0x1b, 0x0a, 0x17, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x4e, 0x4f, 0x41, 0x55, 0x44, 0x49, 0x4f, 0x10, 0x09, 0x12,
	0x18, 0x0a, 0x14, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x55,
	0x42, 0x54, 0x49, 0x54, 0x4c, 0x45, 0x53, 0x10, 0x0a, 0x12, 0x17, 0x0a, 0x13, 0x4d, 0x45, 0x44,
	0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x42, 0x4c, 0x4f, 0x42,
	0x10, 0x0b, 0x2a, 0x64, 0x0a, 0x0c, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x55, 0x72, 0x6c, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x16, 0x0a, 0x12, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x55, 0x52, 0x4c, 0x5f,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x47, 0x43, 0x53, 0x10, 0x00, 0x12, 0x15, 0x0a, 0x11, 0x4d, 0x45,
	0x44, 0x49, 0x41, 0x5f, 0x55, 0x52, 0x4c, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x33, 0x10,
	0x01, 0x12, 0x25, 0x0a, 0x21, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x5f, 0x55, 0x52, 0x4c, 0x5f, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x52, 0x45, 0x43, 0x4f, 0x47, 0x4e, 0x49, 0x5a, 0x45, 0x44,
	0x5f, 0x56, 0x41, 0x4c, 0x55, 0x45, 0x10, 0x02, 0x2a, 0xb4, 0x01, 0x0a, 0x12, 0x4d, 0x65, 0x74,
	0x61, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x54, 0x79, 0x70, 0x65, 0x12,
	0x1e, 0x0a, 0x1a, 0x4d, 0x45, 0x54, 0x41, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x4d, 0x45, 0x44,
	0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4d, 0x41, 0x47, 0x45, 0x10, 0x00, 0x12,
	0x1e, 0x0a, 0x1a, 0x4d, 0x45, 0x54, 0x41, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x4d, 0x45, 0x44,
	0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x56, 0x49, 0x44, 0x45, 0x4f, 0x10, 0x01, 0x12,
	0x1c, 0x0a, 0x18, 0x4d, 0x45, 0x54, 0x41, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x4d, 0x45, 0x44,
	0x49, 0x41, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x47, 0x49, 0x46, 0x10, 0x02, 0x12, 0x1e, 0x0a,
	0x1a, 0x4d, 0x45, 0x54, 0x41, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41,
	0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x55, 0x44, 0x49, 0x4f, 0x10, 0x03, 0x12, 0x20, 0x0a,
	0x1c, 0x4d, 0x45, 0x54, 0x41, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41,
	0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x04, 0x2a,
	0x43, 0x0a, 0x0b, 0x4f, 0x72, 0x69, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x18,
	0x0a, 0x14, 0x4f, 0x52, 0x49, 0x45, 0x4e, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x56, 0x45,
	0x52, 0x54, 0x49, 0x43, 0x41, 0x4c, 0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16, 0x4f, 0x52, 0x49, 0x45,
	0x4e, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x48, 0x4f, 0x52, 0x49, 0x5a, 0x4f, 0x4e, 0x54,
	0x41, 0x4c, 0x10, 0x01, 0x2a, 0xc5, 0x02, 0x0a, 0x12, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79,
	0x4f, 0x72, 0x69, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x19, 0x44,
	0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x5f, 0x4f, 0x52, 0x49, 0x45, 0x4e, 0x54, 0x41, 0x54, 0x49,
	0x4f, 0x4e, 0x5f, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16, 0x44, 0x49,
	0x53, 0x50, 0x4c, 0x41, 0x59, 0x5f, 0x4f, 0x52, 0x49, 0x45, 0x4e, 0x54, 0x41, 0x54, 0x49, 0x4f,
	0x4e, 0x5f, 0x55, 0x50, 0x10, 0x01, 0x12, 0x1c, 0x0a, 0x18, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41,
	0x59, 0x5f, 0x4f, 0x52, 0x49, 0x45, 0x4e, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x44, 0x4f,
	0x57, 0x4e, 0x10, 0x02, 0x12, 0x1c, 0x0a, 0x18, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x5f,
	0x4f, 0x52, 0x49, 0x45, 0x4e, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x4c, 0x45, 0x46, 0x54,
	0x10, 0x03, 0x12, 0x1d, 0x0a, 0x19, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x5f, 0x4f, 0x52,
	0x49, 0x45, 0x4e, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x52, 0x49, 0x47, 0x48, 0x54, 0x10,
	0x04, 0x12, 0x23, 0x0a, 0x1f, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x5f, 0x4f, 0x52, 0x49,
	0x45, 0x4e, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x55, 0x50, 0x5f, 0x4d, 0x49, 0x52, 0x52,
	0x4f, 0x52, 0x45, 0x44, 0x10, 0x05, 0x12, 0x25, 0x0a, 0x21, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41,
	0x59, 0x5f, 0x4f, 0x52, 0x49, 0x45, 0x4e, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x44, 0x4f,
	0x57, 0x4e, 0x5f, 0x4d, 0x49, 0x52, 0x52, 0x4f, 0x52, 0x45, 0x44, 0x10, 0x06, 0x12, 0x25, 0x0a,
	0x21, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x5f, 0x4f, 0x52, 0x49, 0x45, 0x4e, 0x54, 0x41,
	0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x4c, 0x45, 0x46, 0x54, 0x5f, 0x4d, 0x49, 0x52, 0x52, 0x4f, 0x52,
	0x45, 0x44, 0x10, 0x07, 0x12, 0x26, 0x0a, 0x22, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x5f,
	0x4f, 0x52, 0x49, 0x45, 0x4e, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x52, 0x49, 0x47, 0x48,
	0x54, 0x5f, 0x4d, 0x49, 0x52, 0x52, 0x4f, 0x52, 0x45, 0x44, 0x10, 0x08, 0x42, 0x0b, 0x5a, 0x09,
	0x2e, 0x2e, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x33,
}

var (
	file_media_proto_rawDescOnce sync.Once
	file_media_proto_rawDescData = file_media_proto_rawDesc
)

func file_media_proto_rawDescGZIP() []byte {
	file_media_proto_rawDescOnce.Do(func() {
		file_media_proto_rawDescData = protoimpl.X.CompressGZIP(file_media_proto_rawDescData)
	})
	return file_media_proto_rawDescData
}

var file_media_proto_enumTypes = make([]protoimpl.EnumInfo, 12)
var file_media_proto_msgTypes = make([]protoimpl.MessageInfo, 14)
var file_media_proto_goTypes = []interface{}{
	(MediaReference_ClaimBehavior)(0),          // 0: media.MediaReference_ClaimBehavior
	(VideoDescription_VideoPlaybackType)(0),    // 1: media.VideoDescription_VideoPlaybackType
	(VideoDescription_MediaQualityType)(0),     // 2: media.VideoDescription_MediaQualityType
	(VideoFileFormat)(0),                       // 3: media.VideoFileFormat
	(AudioCodecFormat)(0),                      // 4: media.AudioCodecFormat
	(ImageCodecFormat)(0),                      // 5: media.ImageCodecFormat
	(VideoCodecFormat)(0),                      // 6: media.VideoCodecFormat
	(MediaType)(0),                             // 7: media.MediaType
	(MediaUrlType)(0),                          // 8: media.MediaUrlType
	(Metadata_MediaType)(0),                    // 9: media.Metadata_MediaType
	(Orientation)(0),                           // 10: media.Orientation
	(DisplayOrientation)(0),                    // 11: media.DisplayOrientation
	(*MediaMetadata)(nil),                      // 12: media.MediaMetadata
	(*MediaReferences)(nil),                    // 13: media.MediaReferences
	(*ContentEnvelope_MediaReferenceList)(nil), // 14: media.ContentEnvelope_MediaReferenceList
	(*AudioMetadata)(nil),                      // 15: media.AudioMetadata
	(*ImageMetadata)(nil),                      // 16: media.ImageMetadata
	(*VideoMetadata)(nil),                      // 17: media.VideoMetadata
	(*CaptureCharacteristics)(nil),             // 18: media.CaptureCharacteristics
	(*MediaMetadata_MediaDimensions)(nil),      // 19: media.MediaMetadata_MediaDimensions
	(*ThumbnailInfo)(nil),                      // 20: media.ThumbnailInfo
	(*MediaId)(nil),                            // 21: media.MediaId
	(*MediaReference)(nil),                     // 22: media.MediaReference
	(*VideoDescription)(nil),                   // 23: media.VideoDescription
	(*LegacyMediaSource)(nil),                  // 24: media.LegacyMediaSource
	(*LegacyDirectDownloadUrl)(nil),            // 25: media.LegacyDirectDownloadUrl
	(*MediaEncryptionInfo)(nil),                // 26: crypto.MediaEncryptionInfo
	(AssetType)(0),                             // 27: common.AssetType
}
var file_media_proto_depIdxs = []int32{
	9,  // 0: media.MediaMetadata.type:type_name -> media.Metadata_MediaType
	10, // 1: media.MediaMetadata.orientation:type_name -> media.Orientation
	26, // 2: media.MediaMetadata.encryptionInfoV1:type_name -> crypto.MediaEncryptionInfo
	19, // 3: media.MediaMetadata.dimensions:type_name -> media.MediaMetadata_MediaDimensions
	24, // 4: media.MediaMetadata.legacyMediaSource:type_name -> media.LegacyMediaSource
	22, // 5: media.MediaMetadata.mediaReference:type_name -> media.MediaReference
	21, // 6: media.MediaMetadata.mediaId:type_name -> media.MediaId
	26, // 7: media.MediaMetadata.encryptionInfoV2:type_name -> crypto.MediaEncryptionInfo
	27, // 8: media.MediaMetadata.assetType:type_name -> common.AssetType
	18, // 9: media.MediaMetadata.captureCharacteristics:type_name -> media.CaptureCharacteristics
	11, // 10: media.MediaMetadata.displayOrientation:type_name -> media.DisplayOrientation
	15, // 11: media.MediaMetadata.audio:type_name -> media.AudioMetadata
	16, // 12: media.MediaMetadata.image:type_name -> media.ImageMetadata
	17, // 13: media.MediaMetadata.video:type_name -> media.VideoMetadata
	14, // 14: media.MediaReferences.mediaReferenceLists:type_name -> media.ContentEnvelope_MediaReferenceList
	22, // 15: media.ContentEnvelope_MediaReferenceList.reference:type_name -> media.MediaReference
	4,  // 16: media.AudioMetadata.codecFormat:type_name -> media.AudioCodecFormat
	5,  // 17: media.ImageMetadata.codecFormat:type_name -> media.ImageCodecFormat
	6,  // 18: media.VideoMetadata.codecFormat:type_name -> media.VideoCodecFormat
	3,  // 19: media.VideoMetadata.containerFormat:type_name -> media.VideoFileFormat
	21, // 20: media.ThumbnailInfo.mediaId:type_name -> media.MediaId
	23, // 21: media.MediaReference.videoDescription:type_name -> media.VideoDescription
	0,  // 22: media.MediaReference.claimBehavior:type_name -> media.MediaReference_ClaimBehavior
	7,  // 23: media.MediaReference.mediaType:type_name -> media.MediaType
	1,  // 24: media.VideoDescription.videoPlaybackType:type_name -> media.VideoDescription_VideoPlaybackType
	2,  // 25: media.VideoDescription.mediaQualityType:type_name -> media.VideoDescription_MediaQualityType
	25, // 26: media.LegacyMediaSource.directDownloadUrl:type_name -> media.LegacyDirectDownloadUrl
	8,  // 27: media.LegacyDirectDownloadUrl.type:type_name -> media.MediaUrlType
	28, // [28:28] is the sub-list for method output_type
	28, // [28:28] is the sub-list for method input_type
	28, // [28:28] is the sub-list for extension type_name
	28, // [28:28] is the sub-list for extension extendee
	0,  // [0:28] is the sub-list for field type_name
}

func init() { file_media_proto_init() }
func file_media_proto_init() {
	if File_media_proto != nil {
		return
	}
	file_common_proto_init()
	file_crypto_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_media_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MediaMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MediaReferences); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ContentEnvelope_MediaReferenceList); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AudioMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ImageMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VideoMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CaptureCharacteristics); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MediaMetadata_MediaDimensions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ThumbnailInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MediaId); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MediaReference); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VideoDescription); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LegacyMediaSource); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_media_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LegacyDirectDownloadUrl); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_media_proto_msgTypes[0].OneofWrappers = []interface{}{
		(*MediaMetadata_LegacyMediaSource)(nil),
		(*MediaMetadata_ContentDescriptor)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_media_proto_rawDesc,
			NumEnums:      12,
			NumMessages:   14,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_media_proto_goTypes,
		DependencyIndexes: file_media_proto_depIdxs,
		EnumInfos:         file_media_proto_enumTypes,
		MessageInfos:      file_media_proto_msgTypes,
	}.Build()
	File_media_proto = out.File
	file_media_proto_rawDesc = nil
	file_media_proto_goTypes = nil
	file_media_proto_depIdxs = nil
}
